% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/putior.R
\name{put}
\alias{put}
\title{Scan Source Files for PUT Annotations}
\usage{
put(
  path,
  pattern = NULL,
  recursive = TRUE,
  include_line_numbers = FALSE,
  validate = TRUE,
  exclude = NULL,
  log_level = NULL
)
}
\arguments{
\item{path}{Character string specifying the path to the folder containing files,
or path to a single file}

\item{pattern}{Character string specifying the file pattern to match.
Default: all supported extensions (see \code{\link{get_supported_extensions}}).
For a subset, specify a pattern (e.g., "\\.js$" for JavaScript only).}

\item{recursive}{Logical. Should subdirectories be searched recursively?
Default: TRUE}

\item{include_line_numbers}{Logical. Should line numbers be included in output?
Default: FALSE}

\item{validate}{Logical. Should annotations be validated for common issues?
Default: TRUE}

\item{exclude}{Character vector of regex patterns. Files whose full path
matches any pattern are excluded from scanning. Default: NULL (no exclusion).
Example: \code{exclude = c("_meta\\.R$", "deprecated/")}}

\item{log_level}{Character string specifying log verbosity for this call.
Overrides the global option \code{putior.log_level} when specified.
Options: "DEBUG", "INFO", "WARN", "ERROR". See \code{\link{set_putior_log_level}}.}
}
\value{
A data frame containing file names and all properties found in annotations.
Always includes columns: file_name, file_type, and any properties found in
PUT annotations (typically: id, label, node_type, input, output).
Valid \code{node_type} values: \code{"input"}, \code{"process"} (default),
\code{"output"}, \code{"decision"}, \code{"start"}, \code{"end"}.
An additional type \code{"artifact"} is used internally by \code{put_diagram()}
for data file nodes and should not be set manually.
If include_line_numbers is TRUE, also includes line_number.
Note: If output is not specified in an annotation, it defaults to the file name.
}
\description{
Scans source files in a directory for PUT annotations that define workflow
nodes, inputs, outputs, and metadata. Supports multiple programming languages
with their native comment syntax, including single-line and multiline formats.
}
\section{Supported Languages}{

PUT annotations work with any language by using the appropriate comment prefix:
\itemize{
\item \strong{Hash (#)}: R, Python, Shell, Julia, Ruby, Perl, YAML
\item \strong{Dash (--)}: SQL, Lua, Haskell
\item \strong{Slash (//)}: JavaScript, TypeScript, C/C++, Java, Go, Rust, Swift, Kotlin, C#
\item \strong{Percent (\%)}: MATLAB, LaTeX
}
}

\section{PUT Annotation Syntax}{

PUT annotations can be written in single-line or multiline format.
The comment prefix is determined automatically by file extension.

\strong{Single-line format (various languages):}
\preformatted{
# put id:"node1", label:"Process"       # R/Python
--put id:"node1", label:"Query"        -- SQL
//put id:"node1", label:"Handler"      // JavaScript
%put id:"node1", label:"Compute"       % MATLAB
}

\strong{Multiline format:} Use backslash (\\) for line continuation
\preformatted{
# put id:"node1", label:"Process Data", \\
#    input:"data.csv", \\
#    output:"result.csv"
}

\strong{Benefits of multiline format:}
\itemize{
\item Compliance with code style guidelines (styler, lintr)
\item Improved readability for complex workflows
\item Easier maintenance of long file lists
\item Better code organization and documentation
}

\strong{Syntax rules:}
\itemize{
\item End lines with backslash (\\) to continue
\item Each continuation line must start with the appropriate comment marker
\item Properties are automatically joined with proper comma separation
\item Works with all PUT formats: prefix+put, prefix + put, prefix+put|, prefix+put:
}
}

\examples{
\dontrun{
# Scan a directory for workflow annotations (recursive by default)
workflow <- put("./src/")

# Scan top-level only (opt out of recursion)
workflow <- put("./project/", recursive = FALSE)

# Scan a single file
workflow <- put("./script.R")

# Include line numbers for debugging
workflow <- put("./src/", include_line_numbers = TRUE)

# Scan JavaScript/TypeScript files
workflow <- put("./frontend/", pattern = "\\\\.(js|ts|jsx|tsx)$")

# Scan SQL files
workflow <- put("./sql/", pattern = "\\\\.sql$")

# Single-line PUT annotations (various languages):
# R/Python: # put id:"load_data", label:"Load Dataset"
# SQL:      --put id:"query", label:"Execute Query"
# JS/TS:    //put id:"handler", label:"API Handler"
# MATLAB:   \%put id:"compute", label:"Compute Results"
#
# Multiline PUT annotations work the same across languages:
# # put id:"complex_process", label:"Complex Processing", \
# #    input:"file1.csv,file2.csv", \
# #    output:"results.csv"
#
# --put id:"etl_job", label:"ETL Process", \
# --    input:"source_table", \
# --    output:"target_table"
}
}
